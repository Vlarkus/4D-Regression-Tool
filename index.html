<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D Regression Visualizer</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0
        }

        :root {
            --bg: #111827;
            --panel: #1f2937;
            --border: #374151;
            --text: #f9fafb;
            --muted: #9ca3af;
            --accent: #60a5fa;
            --accent2: #a78bfa;
            --green: #34d399
        }

        html,
        body {
            height: 100%;
            width: 100%;
            background: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden
        }

        #app {
            display: flex;
            height: 100vh
        }

        /* ── Sidebar ── */
        #sidebar {
            width: 300px;
            min-width: 300px;
            background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden
        }

        #sb-inner {
            flex: 1;
            overflow-y: auto;
            padding: 14px 14px 20px;
            display: flex;
            flex-direction: column;
            gap: 14px
        }

        #sb-inner::-webkit-scrollbar {
            width: 3px
        }

        #sb-inner::-webkit-scrollbar-thumb {
            background: var(--border)
        }

        .logo {
            font-size: 1.05rem;
            font-weight: 700;
            color: var(--accent);
            letter-spacing: .03em;
            display: flex;
            align-items: center;
            gap: 8px
        }

        .logo svg {
            flex-shrink: 0
        }

        .sec {
            display: flex;
            flex-direction: column;
            gap: 6px
        }

        .sec-hd {
            font-size: .65rem;
            font-weight: 700;
            letter-spacing: .1em;
            text-transform: uppercase;
            color: var(--muted);
            border-bottom: 1px solid var(--border);
            padding-bottom: 4px;
            margin-bottom: 2px
        }

        label {
            font-size: .78rem;
            color: var(--muted)
        }

        select {
            width: 100%;
            background: #0d1117;
            border: 1px solid var(--border);
            color: var(--text);
            padding: 5px 8px;
            border-radius: 6px;
            font-size: .82rem;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%236b7280' stroke-width='2'%3E%3Cpolyline points='6 9 12 15 18 9'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            padding-right: 28px
        }

        select:focus {
            outline: 1px solid var(--accent);
            outline-offset: 1px
        }

        .row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: .82rem;
            color: var(--muted);
            cursor: pointer
        }

        .row input[type=checkbox] {
            width: 15px;
            height: 15px;
            accent-color: var(--accent);
            cursor: pointer;
            flex-shrink: 0
        }

        .range-wrap {
            display: flex;
            flex-direction: column;
            gap: 3px
        }

        .range-row {
            display: flex;
            align-items: center;
            gap: 8px
        }

        .range-row input {
            flex: 1;
            accent-color: var(--accent);
            cursor: pointer
        }

        .range-val {
            font-size: .72rem;
            color: var(--accent2);
            min-width: 50px;
            text-align: right;
            font-variant-numeric: tabular-nums
        }

        .stats-box {
            background: #0d1117;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            font-size: .8rem;
            line-height: 1.8;
            color: var(--text)
        }

        .r2 {
            color: var(--green);
            font-weight: 700;
            font-size: .95rem
        }

        .eq {
            color: var(--accent2);
            font-family: 'Courier New', monospace;
            font-size: .75rem;
            word-break: break-all
        }

        #status {
            font-size: .7rem;
            color: var(--muted);
            min-height: 14px
        }

        .btn {
            width: 100%;
            background: var(--accent);
            color: #0d1117;
            border: none;
            border-radius: 6px;
            padding: 7px;
            font-size: .82rem;
            font-weight: 700;
            cursor: pointer;
            transition: opacity .15s
        }

        .btn:hover {
            opacity: .85
        }

        /* ── Main ── */
        #main {
            flex: 1;
            position: relative;
            background: var(--bg)
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab
        }

        #canvas.dragging {
            cursor: grabbing
        }

        #hint {
            position: absolute;
            bottom: 12px;
            right: 14px;
            font-size: .65rem;
            color: #4b5563;
            line-height: 1.8;
            text-align: right;
            pointer-events: none
        }
    </style>
</head>

<body>
    <div id="app">
        <div id="sidebar">
            <div id="sb-inner">

                <div class="logo">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 3l18 18M3 21L21 3" />
                        <circle cx="12" cy="12" r="3" />
                    </svg>
                    4D Regression
                </div>

                <div class="sec">
                    <div class="sec-hd">Data</div>
                    <label>CSV file (from /data)</label>
                    <select id="file-sel">
                        <option>Scanning…</option>
                    </select>
                    <div id="status">Starting server…</div>
                </div>

                <div id="ctrl-panel" style="display:none;flex-direction:column;gap:14px">

                    <div class="sec">
                        <div class="sec-hd">Axis Mapping</div>
                        <label>X</label><select id="sx"></select>
                        <label>Y</label><select id="sy"></select>
                        <label>Z</label><select id="sz"></select>
                        <label>4th Dimension (W)</label><select id="sw"></select>
                    </div>

                    <div class="sec">
                        <div class="sec-hd">Visibility</div>
                        <label class="row"><input type="checkbox" id="ck-pts" checked> Show points</label>
                        <label class="row"><input type="checkbox" id="ck-col" checked> Color by W</label>
                        <label>Color scale</label>
                        <select id="sel-grad">
                            <option value="viridis">Viridis</option>
                            <option value="plasma">Plasma</option>
                            <option value="inferno">Inferno</option>
                            <option value="cool">Cool</option>
                            <option value="bluered">Blue → Red</option>
                            <option value="spectral">Spectral</option>
                        </select>
                    </div>

                    <div class="sec">
                        <div class="sec-hd">4th Dimension Filter</div>
                        <div class="range-wrap">
                            <div class="range-row">
                                <span style="width:30px;font-size:.7rem;color:var(--muted)">Min</span>
                                <input type="range" id="rng-lo" step="any">
                                <span class="range-val" id="lbl-lo">—</span>
                            </div>
                            <div class="range-row">
                                <span style="width:30px;font-size:.7rem;color:var(--muted)">Max</span>
                                <input type="range" id="rng-hi" step="any">
                                <span class="range-val" id="lbl-hi">—</span>
                            </div>
                        </div>
                    </div>

                    <div class="sec">
                        <div class="sec-hd">Regression Model</div>
                        <label class="row"><input type="checkbox" id="ck-reg"> Show regression surface</label>
                        <label>Model type</label>
                        <select id="sel-model">
                            <option value="linear4d">Linear 4D: aX + bY + cW + d</option>
                            <option value="interaction4d">Interaction 4D: includes XY, XW, YW terms</option>
                            <option value="quadratic4d">Quadratic 4D: full 2nd order in X,Y,W</option>
                            <option value="cubic4d">Cubic 4D: full 3rd order in X,Y,W</option>
                            <option value="log4d">Log-Linear 4D: a·ln(X) + b·ln(Y) + c·ln(W) + d</option>
                            <option value="exp4d">Exp-Linear 4D: exp(aX + bY + cW + d)</option>
                        </select>
                        <label>Display mode</label>
                        <select id="sel-surfmode">
                            <option value="segment">Segment — fixed W slice</option>
                            <option value="space">Space — all W slices</option>
                        </select>
                        <div id="wsurf-row" style="display:none">
                            <label>W fixed on surface: <span class="range-val" id="lbl-wsurf">—</span></label>
                            <input type="range" id="rng-wsurf" step="any" style="width:100%">
                        </div>
                        <div id="space-opts" style="display:none">
                            <label>Space color scale</label>
                            <select id="sel-surfgrad">
                                <option value="viridis">Viridis</option>
                                <option value="plasma">Plasma</option>
                                <option value="inferno">Inferno</option>
                                <option value="cool">Cool</option>
                                <option value="bluered">Blue → Red</option>
                                <option value="spectral">Spectral</option>
                            </select>
                            <label>W slices</label>
                            <div class="range-row">
                                <input type="range" id="rng-slices" min="4" max="20" value="10" step="1">
                                <span class="range-val" id="lbl-slices">10</span>
                            </div>
                            <label>Slice opacity</label>
                            <div class="range-row">
                                <input type="range" id="rng-salpha" min="0.03" max="0.4" value="0.13" step="0.01">
                                <span class="range-val" id="lbl-salpha">0.13</span>
                            </div>
                        </div>
                        <div id="stats" class="stats-box">Enable regression to fit a surface.</div>
                    </div>

                </div><!-- /ctrl-panel -->
            </div>
        </div>

        <div id="main">
            <canvas id="canvas"></canvas>
            <div id="hint">Drag: rotate &nbsp;·&nbsp; Scroll: zoom &nbsp;·&nbsp; Right-drag: pan</div>
        </div>
    </div>

    <script>
        // ════════════════════════════════════════════════
        //  COLOUR MAPS
        // ════════════════════════════════════════════════
        const CMAPS = {
            viridis: [[68, 1, 84], [72, 40, 120], [62, 74, 137], [49, 104, 142], [38, 130, 142], [31, 158, 137], [53, 183, 121], [110, 206, 88], [181, 222, 43], [253, 231, 37]],
            plasma: [[13, 8, 135], [75, 3, 161], [125, 3, 168], [168, 34, 150], [203, 70, 121], [229, 107, 93], [248, 148, 65], [253, 195, 40], [240, 249, 33]],
            inferno: [[0, 0, 4], [40, 11, 84], [101, 21, 110], [159, 42, 99], [212, 72, 66], [245, 125, 21], [252, 185, 80], [252, 255, 164]].reverse(),
            cool: [[0, 255, 255], [50, 200, 255], [100, 150, 255], [150, 100, 255], [200, 50, 255], [255, 0, 255]],
            bluered: [[0, 0, 200], [0, 80, 255], [0, 200, 255], [80, 255, 180], [200, 255, 0], [255, 200, 0], [255, 80, 0], [200, 0, 0]],
            spectral: [[94, 79, 162], [50, 136, 189], [102, 194, 165], [171, 221, 164], [230, 245, 152], [255, 255, 191], [254, 224, 139], [253, 174, 97], [244, 109, 67], [213, 62, 79], [158, 1, 66]]
        };
        function sampleCmap(t, name) {
            const s = CMAPS[name] || CMAPS.viridis;
            t = Math.max(0, Math.min(1, t));
            const pos = t * (s.length - 1), lo = Math.floor(pos), hi = Math.min(lo + 1, s.length - 1), f = pos - lo;
            const r = (s[lo][0] + f * (s[hi][0] - s[lo][0])) | 0;
            const g = (s[lo][1] + f * (s[hi][1] - s[lo][1])) | 0;
            const b = (s[lo][2] + f * (s[hi][2] - s[lo][2])) | 0;
            return [r, g, b];
        }

        // ════════════════════════════════════════════════
        //  MATH / PROJECTION
        // ════════════════════════════════════════════════
        let camTheta = 0.8, camPhi = 0.5, camZoom = 420, camPanX = 0, camPanY = 0;

        function rotate(p, theta, phi) {
            let [x, y, z] = p;
            // Rotate around Y
            let x1 = x * Math.cos(theta) + z * Math.sin(theta);
            let z1 = -x * Math.sin(theta) + z * Math.cos(theta);
            let y1 = y;
            // Rotate around X
            let x2 = x1;
            let y2 = y1 * Math.cos(phi) - z1 * Math.sin(phi);
            let z2 = y1 * Math.sin(phi) + z1 * Math.cos(phi);
            return [x2, y2, z2];
        }

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        function proj(p3) {
            const [x, y, z] = rotate(p3, camTheta, camPhi);
            const fov = camZoom;
            const dz = z + 5;
            const px = x * fov / dz + canvas.width / 2 + camPanX;
            const py = -y * fov / dz + canvas.height / 2 + camPanY;
            return [px, py, z];
        }

        // ════════════════════════════════════════════════
        //  DATA STATE
        // ════════════════════════════════════════════════
        let rows = [], hdr = [], colX = '', colY = '', colZ = '', colW = '';
        let wAbsMin = 0, wAbsMax = 1, wLoVal = 0, wHiVal = 1;
        let showPts = true, colorByW = true, showReg = false, gradName = 'viridis';
        let regResult = null;

        // ════════════════════════════════════════════════
        //  HELPERS
        // ════════════════════════════════════════════════
        function getVals(col) { return rows.map(r => r[col]).filter(v => typeof v === 'number'); }
        function minmax(col) { const v = getVals(col); return [Math.min(...v), Math.max(...v)]; }
        function norm(v, mn, mx) { return mx === mn ? 0 : (v - mn) / (mx - mn) * 2 - 1; }
        function nice(v, d = 3) { return v.toFixed(d); }

        // ════════════════════════════════════════════════
        //  REGRESSION — general OLS + model library
        // ════════════════════════════════════════════════

        // Gaussian elimination with partial pivoting
        function gaussElim(A, b) {
            const n = b.length;
            const M = A.map((row, i) => [...row, b[i]]);
            for (let col = 0; col < n; col++) {
                let maxR = col;
                for (let r = col + 1; r < n; r++) if (Math.abs(M[r][col]) > Math.abs(M[maxR][col])) maxR = r;
                [M[col], M[maxR]] = [M[maxR], M[col]];
                if (Math.abs(M[col][col]) < 1e-14) return null;
                const piv = M[col][col];
                for (let r = 0; r < n; r++) {
                    if (r === col) continue;
                    const f = M[r][col] / piv;
                    for (let c = col; c <= n; c++) M[r][c] -= f * M[col][c];
                }
            }
            return M.map((row, i) => row[n] / row[i]);
        }

        // Fit any model given an array of basis-function closures
        function fitModel(data, bases, czCol) {
            const n = data.length, k = bases.length;
            if (n < k + 1) return null;
            // Filter rows where all bases return finite numbers
            const valid = data.filter(r => bases.every(f => isFinite(f(r))) && isFinite(r[czCol]));
            if (valid.length < k + 1) return null;
            const nv = valid.length;
            // Build XtX (k×k) and Xty (k)
            const XtX = Array.from({ length: k }, () => new Array(k).fill(0));
            const Xty = new Array(k).fill(0);
            valid.forEach(r => {
                const phi = bases.map(f => f(r));
                const z = r[czCol];
                for (let i = 0; i < k; i++) {
                    Xty[i] += phi[i] * z;
                    for (let j = 0; j < k; j++) XtX[i][j] += phi[i] * phi[j];
                }
            });
            const beta = gaussElim(XtX, Xty);
            if (!beta) return null;
            const predict = r => bases.reduce((s, f, i) => s + beta[i] * f(r), 0);
            const meanZ = valid.reduce((s, r) => s + r[czCol], 0) / nv;
            let ssRes = 0, ssTot = 0;
            valid.forEach(r => { ssRes += (r[czCol] - predict(r)) ** 2; ssTot += (r[czCol] - meanZ) ** 2; });
            return { beta, predict, r2: ssTot < 1e-14 ? 1 : 1 - ssRes / ssTot };
        }

        const f4 = v => v.toFixed(4);

        // Model library — ALL models use all 4 dimensions (X, Y, W → Z)
        const MODEL_DEFS = {
            linear4d: {
                needsW: true,
                bases: (cx, cy, cw) => [r => r[cx], r => r[cy], r => r[cw], r => 1],
                eqHTML: (b, cx, cy, cz, cw) => cz + ' = ' + b[0].toFixed(4) + '·' + cx + ' + ' + b[1].toFixed(4) + '·' + cy + ' + ' + b[2].toFixed(4) + '·' + cw + ' + ' + b[3].toFixed(4)
            },
            interaction4d: {
                needsW: true,
                bases: (cx, cy, cw) => [
                    r => r[cx] * r[cy], r => r[cx] * r[cw], r => r[cy] * r[cw],
                    r => r[cx], r => r[cy], r => r[cw], r => 1
                ],
                eqHTML: (b, cx, cy, cz, cw) => cz + ' = ' + b[0].toFixed(4) + '·' + cx + cy + ' + ' + b[1].toFixed(4) + '·' + cx + cw + ' + ' + b[2].toFixed(4) + '·' + cy + cw + ' + ' + b[3].toFixed(4) + '·' + cx + ' + ' + b[4].toFixed(4) + '·' + cy + ' + ' + b[5].toFixed(4) + '·' + cw + ' + ' + b[6].toFixed(4)
            },
            quadratic4d: {
                needsW: true,
                bases: (cx, cy, cw) => [
                    r => r[cx] ** 2, r => r[cy] ** 2, r => r[cw] ** 2,
                    r => r[cx] * r[cy], r => r[cx] * r[cw], r => r[cy] * r[cw],
                    r => r[cx], r => r[cy], r => r[cw], r => 1
                ],
                eqHTML: (b, cx, cy, cz, cw) => cz + ' = ' + b[0].toFixed(4) + '·' + cx + '² + ' + b[1].toFixed(4) + '·' + cy + '² + ' + b[2].toFixed(4) + '·' + cw + '² + ' + b[3].toFixed(4) + '·' + cx + cy + ' + ' + b[4].toFixed(4) + '·' + cx + cw + ' + ' + b[5].toFixed(4) + '·' + cy + cw + ' + ' + b[6].toFixed(4) + '·' + cx + ' + ' + b[7].toFixed(4) + '·' + cy + ' + ' + b[8].toFixed(4) + '·' + cw + ' + ' + b[9].toFixed(4)
            },
            cubic4d: {
                needsW: true,
                bases: (cx, cy, cw) => [
                    r => r[cx] ** 3, r => r[cy] ** 3, r => r[cw] ** 3,
                    r => r[cx] ** 2 * r[cy], r => r[cx] ** 2 * r[cw],
                    r => r[cy] ** 2 * r[cx], r => r[cy] ** 2 * r[cw],
                    r => r[cw] ** 2 * r[cx], r => r[cw] ** 2 * r[cy],
                    r => r[cx] * r[cy] * r[cw],
                    r => r[cx] ** 2, r => r[cy] ** 2, r => r[cw] ** 2,
                    r => r[cx] * r[cy], r => r[cx] * r[cw], r => r[cy] * r[cw],
                    r => r[cx], r => r[cy], r => r[cw], r => 1
                ],
                eqHTML: (b, cx, cy, cz, cw) => cz + ' = ' + b[0].toFixed(4) + '·' + cx + '³ + ' + b[1].toFixed(4) + '·' + cy + '³ + ' + b[2].toFixed(4) + '·' + cw + '³ + … (20 terms)'
            },
            log4d: {
                needsW: true,
                bases: (cx, cy, cw) => [r => Math.log(r[cx]), r => Math.log(r[cy]), r => Math.log(r[cw]), r => 1],
                eqHTML: (b, cx, cy, cz, cw) => cz + ' = ' + b[0].toFixed(4) + '·ln(' + cx + ') + ' + b[1].toFixed(4) + '·ln(' + cy + ') + ' + b[2].toFixed(4) + '·ln(' + cw + ') + ' + b[3].toFixed(4),
                note: 'Requires X, Y, W > 0'
            },
            exp4d: {
                needsW: true,
                isExpLinear: true,
                bases: (cx, cy, cw) => [r => r[cx], r => r[cy], r => r[cw], r => 1],
                eqHTML: (b, cx, cy, cz, cw) => cz + ' = exp(' + b[0].toFixed(4) + '·' + cx + ' + ' + b[1].toFixed(4) + '·' + cy + ' + ' + b[2].toFixed(4) + '·' + cw + ' + ' + b[3].toFixed(4) + ')',
                note: 'Requires Z > 0 (fits ln(Z) = aX + bY + cW + d)'
            }
        };

        // ════════════════════════════════════════════════
        //  DRAW
        // ════════════════════════════════════════════════
        function draw() {
            const W = canvas.width, H = canvas.height;
            ctx.clearRect(0, 0, W, H);

            // Dark background matching Plotly default
            ctx.fillStyle = '#1c2333';
            ctx.fillRect(0, 0, W, H);

            if (!rows.length) {
                ctx.fillStyle = '#6b7280'; ctx.font = '15px system-ui'; ctx.textAlign = 'center';
                ctx.fillText('Select a data file from the sidebar', W / 2, H / 2); return;
            }

            const [xMn, xMx] = minmax(colX), [yMn, yMx] = minmax(colY), [zMn, zMx] = minmax(colZ);
            const [wMn, wMx] = [wAbsMin, wAbsMax];

            // ── Build tick layout ──
            function makeTicks(lo, hi, n = 5) {
                const step = (hi - lo) / (n - 1);
                return Array.from({ length: n }, (_, i) => lo + i * step);
            }
            const xTicks = makeTicks(xMn, xMx), yTicks = makeTicks(yMn, yMx), zTicks = makeTicks(zMn, zMx);
            function nx(v) { return norm(v, xMn, xMx); }
            function ny(v) { return norm(v, yMn, yMx); }
            function nz(v) { return norm(v, zMn, zMx); }

            // ── Cube corners (normalised -1..1) ──
            const C = {
                lll: [-1, -1, -1], rll: [1, -1, -1], rrl: [1, 1, -1], lrl: [-1, 1, -1],
                llh: [-1, -1, 1], rlh: [1, -1, 1], rrh: [1, 1, 1], lrh: [-1, 1, 1]
            };

            // Project and get avg depth of each face for back-face ordering
            function faceZ(pts) { return pts.reduce((s, p) => s + rotate(p, camTheta, camPhi)[2], 0) / pts.length; }

            // ── Grid helper ──
            function drawGrid(corner, axU, axV, colU, colV, numU, numV, styleStroke) {
                ctx.strokeStyle = styleStroke;
                ctx.lineWidth = 0.8;
                // Lines along U direction (varying V)
                for (let v = 0; v <= numV; v++) {
                    const t = v / numV;
                    const start = [corner[0] + t * axV[0], corner[1] + t * axV[1], corner[2] + t * axV[2]];
                    const end = [start[0] + axU[0], start[1] + axU[1], start[2] + axU[2]];
                    const ps = proj(start), pe = proj(end);
                    ctx.beginPath(); ctx.moveTo(ps[0], ps[1]); ctx.lineTo(pe[0], pe[1]); ctx.stroke();
                }
                // Lines along V direction (varying U)
                for (let u = 0; u <= numU; u++) {
                    const t = u / numU;
                    const start = [corner[0] + t * axU[0], corner[1] + t * axU[1], corner[2] + t * axU[2]];
                    const end = [start[0] + axV[0], start[1] + axV[1], start[2] + axV[2]];
                    const ps = proj(start), pe = proj(end);
                    ctx.beginPath(); ctx.moveTo(ps[0], ps[1]); ctx.lineTo(pe[0], pe[1]); ctx.stroke();
                }
            }

            // ── Determine which of the 3 floor/wall faces to show (back-facing) ──
            // Floor (y=-1), left wall (x=-1), back wall (z=-1)
            const floorZ = faceZ([C.lll, C.rll, C.rlh, C.llh]);
            const wallXZ = faceZ([C.lll, C.lrl, C.lrh, C.llh]);
            const wallZZ = faceZ([C.lll, C.rll, C.rrl, C.lrl]);

            // Sort faces back to front
            const bgFaces = [
                {
                    z: floorZ, draw: () => {
                        ctx.fillStyle = 'rgba(30,40,60,0.6)';
                        const pts = [C.lll, C.rll, C.rlh, C.llh].map(proj);
                        ctx.beginPath(); pts.forEach((p, i) => i ? ctx.lineTo(p[0], p[1]) : ctx.moveTo(p[0], p[1])); ctx.closePath(); ctx.fill();
                        drawGrid([-1, -1, -1], [2, 0, 0], [0, 0, 2], 'x', 'z', 5, 5, 'rgba(80,100,140,0.45)');
                    }
                },
                {
                    z: wallXZ, draw: () => {
                        ctx.fillStyle = 'rgba(28,38,58,0.55)';
                        const pts = [C.lll, C.lrl, C.lrh, C.llh].map(proj);
                        ctx.beginPath(); pts.forEach((p, i) => i ? ctx.lineTo(p[0], p[1]) : ctx.moveTo(p[0], p[1])); ctx.closePath(); ctx.fill();
                        drawGrid([-1, -1, -1], [0, 2, 0], [0, 0, 2], 'y', 'z', 5, 5, 'rgba(80,100,140,0.45)');
                    }
                },
                {
                    z: wallZZ, draw: () => {
                        ctx.fillStyle = 'rgba(26,36,56,0.5)';
                        const pts = [C.lll, C.rll, C.rrl, C.lrl].map(proj);
                        ctx.beginPath(); pts.forEach((p, i) => i ? ctx.lineTo(p[0], p[1]) : ctx.moveTo(p[0], p[1])); ctx.closePath(); ctx.fill();
                        drawGrid([-1, -1, -1], [2, 0, 0], [0, 2, 0], 'x', 'y', 5, 5, 'rgba(80,100,140,0.45)');
                    }
                },
            ].sort((a, b) => a.z - b.z);
            bgFaces.forEach(f => f.draw());

            // ── Cube edges ──
            const edges = [
                [C.lll, C.rll], [C.rll, C.rrl], [C.rrl, C.lrl], [C.lrl, C.lll],
                [C.llh, C.rlh], [C.rlh, C.rrh], [C.rrh, C.lrh], [C.lrh, C.llh],
                [C.lll, C.llh], [C.rll, C.rlh], [C.rrl, C.rrh], [C.lrl, C.lrh]
            ];
            ctx.strokeStyle = 'rgba(100,130,180,0.5)'; ctx.lineWidth = 1;
            edges.forEach(([a, b]) => {
                const pa = proj(a), pb = proj(b);
                ctx.beginPath(); ctx.moveTo(pa[0], pa[1]); ctx.lineTo(pb[0], pb[1]); ctx.stroke();
            });

            // ── Axis tick labels ──
            ctx.textAlign = 'center'; ctx.font = `${Math.round(10 * devicePixelRatio * 0.7)}px 'Courier New',monospace`;
            ctx.fillStyle = '#8090b0';
            const tickLen = 0.07;
            // X ticks along bottom-front edge
            xTicks.forEach(v => {
                const p = proj([nx(v), -1, -1]);
                ctx.fillText(v.toFixed(1), p[0], p[1] + 14);
            });
            // Y ticks along left-front edge
            yTicks.forEach(v => {
                const p = proj([-1, ny(v), -1]);
                ctx.fillText(v.toFixed(1), p[0] - 20, p[1] + 4);
            });
            // Z ticks along back-left vertical edge
            zTicks.forEach(v => {
                const p = proj([-1, -1, nz(v)]);
                ctx.fillText(v.toFixed(1), p[0] - 20, p[1] + 4);
            });

            // ── Axis labels ──
            ctx.font = `bold ${Math.round(12 * devicePixelRatio * 0.65)}px system-ui`;
            ctx.fillStyle = '#93c5fd';
            const xLbl = proj([0, -1.22, -1.22]); ctx.fillText(colX, xLbl[0], xLbl[1]);
            ctx.fillStyle = '#86efac';
            const yLbl = proj([-1.28, 0, -1.22]); ctx.fillText(colY, yLbl[0], yLbl[1]);
            ctx.fillStyle = '#c4b5fd';
            const zLbl = proj([-1.3, -1.15, 0]); ctx.fillText(colZ, zLbl[0], zLbl[1]);

            // ── Regression surface ──
            if (showReg && regResult) {
                const STEPS = 12;
                const allQuads = [];

                function buildSlice(wVal, fillColor, strokeColor) {
                    const grid = [];
                    for (let i = 0; i <= STEPS; i++) {
                        grid[i] = [];
                        for (let j = 0; j <= STEPS; j++) {
                            const xv = xMn + (xMx - xMn) * (i / STEPS);
                            const yv = yMn + (yMx - yMn) * (j / STEPS);
                            const fakeRow = { [colX]: xv, [colY]: yv, [colZ]: 0, [colW]: wVal };
                            const zv = regResult.predict(fakeRow);
                            const nzv = isFinite(zv) ? nz(Math.max(zMn, Math.min(zMx, zv))) : null;
                            grid[i][j] = nzv !== null ? proj([nx(xv), ny(yv), nzv]) : null;
                        }
                    }
                    for (let i = 0; i < STEPS; i++) for (let j = 0; j < STEPS; j++) {
                        const p00 = grid[i][j], p10 = grid[i + 1][j], p11 = grid[i + 1][j + 1], p01 = grid[i][j + 1];
                        if (!p00 || !p10 || !p11 || !p01) continue;
                        allQuads.push({ z: (p00[2] + p10[2] + p11[2] + p01[2]) / 4, pts: [p00, p10, p11, p01], fill: fillColor, stroke: strokeColor });
                    }
                }

                if (surfMode === 'segment') {
                    buildSlice(wSurfVal, 'rgba(139,92,246,0.18)', 'rgba(139,92,246,0.4)');
                } else {
                    const N = surfSlices;
                    for (let k = 0; k < N; k++) {
                        const wVal = wAbsMin + (wAbsMax - wAbsMin) * (k / Math.max(N - 1, 1));
                        const wt = (wVal - wAbsMin) / (wAbsMax - wAbsMin || 1);
                        const [rc, gc, bc] = sampleCmap(wt, surfGrad);
                        buildSlice(wVal,
                            `rgba(${rc},${gc},${bc},${surfAlpha})`,
                            `rgba(${rc},${gc},${bc},${Math.min(1, surfAlpha * 2.5)})`
                        );
                    }
                }

                allQuads.sort((a, b) => b.z - a.z);
                allQuads.forEach(({ pts: [p00, p10, p11, p01], fill, stroke }) => {
                    ctx.beginPath();
                    ctx.moveTo(p00[0], p00[1]); ctx.lineTo(p10[0], p10[1]);
                    ctx.lineTo(p11[0], p11[1]); ctx.lineTo(p01[0], p01[1]); ctx.closePath();
                    ctx.fillStyle = fill; ctx.fill();
                    ctx.strokeStyle = stroke; ctx.lineWidth = 0.5; ctx.stroke();
                });
            }

            // ── Points ──
            if (showPts) {
                const visible = rows.filter(r => {
                    const w = r[colW];
                    return typeof w === 'number' && w >= wLoVal && w <= wHiVal;
                });
                // Project all, depth sort
                const pts = visible.map(r => {
                    const xv = r[colX], yv = r[colY], zv = r[colZ], wv = r[colW];
                    if ([xv, yv, zv, wv].some(v => typeof v !== 'number')) return null;
                    const p = proj([nx(xv), ny(yv), nz(zv)]);
                    const wt = (wv - wMn) / (wMx - wMn || 1);
                    return { p, wt };
                }).filter(Boolean);
                pts.sort((a, b) => b.p[2] - a.p[2]);

                const pr = Math.max(3, Math.min(6, 4.5 * devicePixelRatio));
                // Pass 1: glows only — drawn first so they never overdraw any solid dot
                pts.forEach(({ p, wt }) => {
                    const [r, g, b] = sampleCmap(colorByW ? wt : 0.6, gradName);
                    const grd = ctx.createRadialGradient(p[0], p[1], 0, p[0], p[1], pr * 2.5);
                    grd.addColorStop(0, `rgba(${r},${g},${b},0.2)`);
                    grd.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.beginPath(); ctx.arc(p[0], p[1], pr * 2.5, 0, Math.PI * 2); ctx.fillStyle = grd; ctx.fill();
                });
                // Pass 2: solid fills + rim (back-to-front so closer points sit on top)
                pts.forEach(({ p, wt }) => {
                    const [r, g, b] = sampleCmap(colorByW ? wt : 0.6, gradName);
                    ctx.beginPath(); ctx.arc(p[0], p[1], pr, 0, Math.PI * 2);
                    ctx.fillStyle = `rgb(${r},${g},${b})`; ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.28)'; ctx.lineWidth = 0.8; ctx.stroke();
                });
            }

            // ── Colorbar ──
            if (colorByW && showPts) {
                const bx = W - 32, by = H * 0.12, bh = H * 0.65, bw = 12;
                const cg = ctx.createLinearGradient(0, by + bh, 0, by);
                for (let i = 0; i <= 10; i++) { const [r, g, b] = sampleCmap(i / 10, gradName); cg.addColorStop(i / 10, `rgb(${r},${g},${b})`); }
                ctx.fillStyle = cg; ctx.fillRect(bx, by, bw, bh);
                ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 1; ctx.strokeRect(bx, by, bw, bh);
                ctx.fillStyle = '#8090b0'; ctx.font = `${Math.round(9 * devicePixelRatio * 0.7)}px 'Courier New'`; ctx.textAlign = 'right';
                ctx.fillText(wAbsMax.toFixed(2), bx - 4, by + 6);
                ctx.fillText(((wAbsMin + wAbsMax) / 2).toFixed(2), bx - 4, by + bh / 2 + 4);
                ctx.fillText(wAbsMin.toFixed(2), bx - 4, by + bh + 4);
                ctx.save(); ctx.translate(bx - 16, by + bh / 2); ctx.rotate(-Math.PI / 2);
                ctx.textAlign = 'center'; ctx.fillText(colW, 0, 0); ctx.restore();
            }
        }

        // ════════════════════════════════════════════════
        //  RESIZE
        // ════════════════════════════════════════════════
        function resize() {
            canvas.width = canvas.clientWidth * devicePixelRatio;
            canvas.height = canvas.clientHeight * devicePixelRatio;
            draw();
        }
        window.addEventListener('resize', resize);

        // ════════════════════════════════════════════════
        //  MOUSE
        // ════════════════════════════════════════════════
        let drag = null;
        canvas.addEventListener('mousedown', e => {
            drag = { x: e.clientX, y: e.clientY, btn: e.button, theta: camTheta, phi: camPhi, px: camPanX, py: camPanY };
            canvas.classList.add('dragging');
        });
        window.addEventListener('mousemove', e => {
            if (!drag) return;
            const dx = e.clientX - drag.x, dy = e.clientY - drag.y;
            if (drag.btn === 0) { camTheta = drag.theta - dx * 0.007; camPhi = drag.phi - dy * 0.007; camPhi = Math.max(-Math.PI / 2 + 0.05, Math.min(Math.PI / 2 - 0.05, camPhi)); }
            else { camPanX = drag.px + dx * devicePixelRatio; camPanY = drag.py + dy * devicePixelRatio; }
            draw();
        });
        window.addEventListener('mouseup', () => { drag = null; canvas.classList.remove('dragging'); });
        canvas.addEventListener('wheel', e => { e.preventDefault(); camZoom *= e.deltaY < 0 ? 1.09 : 0.92; draw(); }, { passive: false });
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // ════════════════════════════════════════════════
        //  CONTROLS WIRING
        // ════════════════════════════════════════════════
        const fileSel = $('file-sel'), ctrlPanel = $('ctrl-panel'), statusEl = $('status');
        const sx = $('sx'), sy = $('sy'), sz = $('sz'), sw = $('sw');
        const ckPts = $('ck-pts'), ckCol = $('ck-col'), ckReg = $('ck-reg'), selGrad = $('sel-grad');
        const rngLo = $('rng-lo'), rngHi = $('rng-hi'), lblLo = $('lbl-lo'), lblHi = $('lbl-hi');
        const statsDiv = $('stats');
        function $(id) { return document.getElementById(id); }

        function populateCols() {
            [sx, sy, sz, sw].forEach(s => {
                s.innerHTML = '';
                hdr.forEach(h => { const o = document.createElement('option'); o.value = h; o.textContent = h; s.appendChild(o); });
            });
            if (hdr.length >= 4) { sx.selectedIndex = 0; sy.selectedIndex = 1; sz.selectedIndex = 2; sw.selectedIndex = 3; }
            applyMapping();
        }

        function applyMapping() {
            colX = sx.value; colY = sy.value; colZ = sz.value; colW = sw.value;
            const wv = rows.map(r => r[colW]).filter(v => typeof v === 'number');
            wAbsMin = Math.min(...wv); wAbsMax = Math.max(...wv);
            rngLo.min = wAbsMin; rngLo.max = wAbsMax; rngLo.value = wAbsMin;
            rngHi.min = wAbsMin; rngHi.max = wAbsMax; rngHi.value = wAbsMax;
            wLoVal = wAbsMin; wHiVal = wAbsMax;
            lblLo.textContent = wAbsMin.toFixed(3); lblHi.textContent = wAbsMax.toFixed(3);
            updateReg(); draw();
        }

        let wSurfVal = 0;
        let surfMode = 'segment', surfGrad = 'viridis', surfSlices = 10, surfAlpha = 0.13;

        function updateWsurfSlider() {
            const on = showReg;
            wsurfRow.style.display = (on && surfMode === 'segment') ? 'block' : 'none';
            spaceOpts.style.display = (on && surfMode === 'space') ? 'block' : 'none';
            if (on) {
                rngWsurf.min = wAbsMin; rngWsurf.max = wAbsMax;
                if (wSurfVal < wAbsMin || wSurfVal > wAbsMax) {
                    wSurfVal = (wAbsMin + wAbsMax) / 2;
                    rngWsurf.value = wSurfVal;
                }
                lblWsurf.textContent = wSurfVal.toFixed(3);
            }
        }

        function updateReg() {
            if (showReg) {
                const modelKey = selModel.value;
                const def = MODEL_DEFS[modelKey];
                if (!def) return;

                let dataForFit = rows;
                let czCol = colZ;

                if (def.isExpLinear) {
                    // Fit ln(Z) instead of Z; predict returns exp(...)
                    dataForFit = rows.map(r => ({ ...r, [colZ + '__ln']: Math.log(r[colZ]) })).filter(r => isFinite(r[colZ + '__ln']));
                    czCol = colZ + '__ln';
                }

                const bases = def.bases(colX, colY, colW);
                const fit = fitModel(dataForFit, bases, czCol);

                if (!fit) {
                    statsDiv.innerHTML = '<span style="color:#f87171">Could not fit (degenerate / insufficient data).</span>';
                    regResult = null; return;
                }

                if (def.isExpLinear) {
                    // Wrap predict to return exp of the linear fit
                    const innerPredict = fit.predict;
                    fit.predict = r => Math.exp(innerPredict({ ...r, [colZ + '__ln']: Math.log(r[colZ] || 1) }));
                    // Re-compute R² on original Z scale
                    const meanZ = rows.reduce((s, r) => s + r[colZ], 0) / rows.length;
                    let ssRes = 0, ssTot = 0;
                    rows.forEach(r => { ssRes += (r[colZ] - fit.predict(r)) ** 2; ssTot += (r[colZ] - meanZ) ** 2; });
                    fit.r2 = ssTot < 1e-14 ? 1 : 1 - ssRes / ssTot;
                }

                regResult = fit;
                const noteHtml = def.note ? `<br><span style="color:#fbbf24;font-size:.72rem">${def.note}</span>` : '';
                statsDiv.innerHTML = `<b>R²</b> = <span class="r2">${fit.r2.toFixed(5)}</span>  (n=${rows.length})<br><span class="eq">${def.eqHTML(fit.beta, colX, colY, colZ, colW)}</span>${noteHtml}`;
            } else {
                regResult = null;
                statsDiv.textContent = 'Enable regression to fit a surface.';
            }
        }

        const selModel = $('sel-model');
        const selSurfmode = $('sel-surfmode');
        const selSurfgrad = $('sel-surfgrad');
        const wsurfRow = $('wsurf-row');
        const spaceOpts = $('space-opts');
        const rngWsurf = $('rng-wsurf');
        const lblWsurf = $('lbl-wsurf');
        const rngSlices = $('rng-slices');
        const lblSlices = $('lbl-slices');
        const rngSalpha = $('rng-salpha');
        const lblSalpha = $('lbl-salpha');

        [sx, sy, sz, sw].forEach(s => s.addEventListener('change', applyMapping));
        ckPts.addEventListener('change', () => { showPts = ckPts.checked; draw(); });
        ckCol.addEventListener('change', () => { colorByW = ckCol.checked; draw(); });
        selGrad.addEventListener('change', () => { gradName = selGrad.value; draw(); });
        ckReg.addEventListener('change', () => { showReg = ckReg.checked; updateWsurfSlider(); updateReg(); draw(); });
        selModel.addEventListener('change', () => { updateWsurfSlider(); updateReg(); draw(); });
        selSurfmode.addEventListener('change', () => { surfMode = selSurfmode.value; updateWsurfSlider(); draw(); });
        selSurfgrad.addEventListener('change', () => { surfGrad = selSurfgrad.value; draw(); });
        rngSlices.addEventListener('input', () => { surfSlices = parseInt(rngSlices.value); lblSlices.textContent = surfSlices; draw(); });
        rngSalpha.addEventListener('input', () => { surfAlpha = parseFloat(rngSalpha.value); lblSalpha.textContent = surfAlpha.toFixed(2); draw(); });
        rngWsurf.addEventListener('input', () => { wSurfVal = parseFloat(rngWsurf.value); lblWsurf.textContent = wSurfVal.toFixed(3); draw(); });
        rngLo.addEventListener('input', () => {
            wLoVal = parseFloat(rngLo.value);
            if (wLoVal > wHiVal) { wHiVal = wLoVal; rngHi.value = wLoVal; }
            lblLo.textContent = wLoVal.toFixed(3); draw();
        });
        rngHi.addEventListener('input', () => {
            wHiVal = parseFloat(rngHi.value);
            if (wHiVal < wLoVal) { wLoVal = wHiVal; rngLo.value = wHiVal; }
            lblHi.textContent = wHiVal.toFixed(3); draw();
        });

        // ════════════════════════════════════════════════
        //  DATA LOADING
        // ════════════════════════════════════════════════
        function loadFile(name) {
            statusEl.textContent = `Loading ${name}…`;
            fetch('/api/data?file=' + encodeURIComponent(name))
                .then(r => r.json())
                .then(d => {
                    if (d.error) { statusEl.textContent = 'Error: ' + d.error; return; }
                    rows = d.rows; hdr = d.headers;
                    statusEl.textContent = `${rows.length} rows · ${hdr.length} columns`;
                    ctrlPanel.style.display = 'flex';
                    populateCols();
                })
                .catch(e => statusEl.textContent = 'Load failed: ' + e);
        }

        fetch('/api/files')
            .then(r => r.json())
            .then(files => {
                fileSel.innerHTML = '';
                if (!files.length) {
                    fileSel.innerHTML = '<option>No CSVs in /data</option>';
                    statusEl.textContent = 'Add CSV files to the /data folder and restart.';
                    return;
                }
                files.forEach(f => { const o = document.createElement('option'); o.value = f; o.textContent = f; fileSel.appendChild(o); });
                fileSel.addEventListener('change', () => loadFile(fileSel.value));
                loadFile(files[0]);
            })
            .catch(e => statusEl.textContent = 'Server error: ' + e);

        resize();
    </script>
</body>

</html>